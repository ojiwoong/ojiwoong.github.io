{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n## 들어가기 앞서\r\n자바스크립트의 반복문에는 크게 for 문, foreach 문, for...in 문, for...of문 등이 있습니다.  \r\n이 반복문들의 특징과 차이점에 대해서 알아보려고 합니다.\r\n\r\n## for 문\r\nfor 반복문 일반적인 반복문입니다.\r\n\r\n```jsx\r\nlet arr = [\"오\", \"지\", \"웅\"];\r\nfor (let i = 0; i < arr.length; i++) {\r\n  console.log(arr[i]); // 오, 지, 웅\r\n}\r\n```\r\n\r\n## foreach 문\r\n\r\nforeach 문은 Array 객체에서 사용할 수 있는 메서드입니다. \r\n(ES6부터는 Map,Set 에서도 지원한다고 합니다.)\r\n배열의 요소들을 반복하며, callback 함수를 등록할 수 있고, 배열의 각 요소들이 반복될 때 이 clalback 함수가 호출됩니다. \r\n\r\n```jsx\r\nlet arr = [\"오\", \"지\", \"웅\"];\r\narr.forEach(function (item, index, arr2) {\r\n  console.log(item, index, arr2); // 오 0 arr, 지 1 arr, 웅 2 arr\r\n});\r\n```\r\n\r\n##for...in 문\r\n\r\n객체에 사용할 수 있으며, 객체의 key값과 value값을 가져오는데 유용합니다.\r\n객체의 키값의 개수만큼 반복합니다.\r\nfor...in은 객체의 반복을 위해 만들어졌지만, 배열의 반역을 위해서는 추천하지 않습니다.\r\n이미 Array.prototype.forEach(), for...of 문이 존재합니다.\r\n\r\n객체의 속성을 확인할 수 있기 때문에, 실질적으로 디버깅을 위해 사용되거나, 특정 키가 있는지 확인할 때 주로 사용할 수 있습니다.\r\n\r\n```jsx\r\nvar obj = {\r\n  one: \"오\",\r\n  two: \"지\",\r\n  three: \"웅\",\r\n};\r\n\r\nfor (var key in obj) {\r\n  console.log(key, obj[key]); // one 오, two 지, three 웅\r\n}\r\n```\r\n\r\n##for...of 문\r\n\r\nfor of 반복문은 ES6에 추가된 새로운 컬렉션 반복문입니다.\r\nfor of 구문을 사용하기 위해선 컬렉션 객체가 [Symbol.iterator] 속성을 가지고 있어야만 합니다.\r\nInternet Explorer에서는 지원하지 않아, 크로스 브라우저를 고려할때는 사용에 유의해야 합니다.\r\n\r\n```jsx\r\nvar iterable = [2, 0, 2, 1]\r\n\r\nfor (var value in iterable) {\r\n  console.log(key, obj[key]);\r\n}\r\n\r\n// 출력\r\n2\r\n0\r\n2\r\n1\r\n```\r\n\r\n## for...in 문 과 for...of 문의 차이점\r\n\r\nfor...in 문 : 객체의 모든 열거 가능한 속성(property)에 대한 반복\r\nfor...of 문 : [symbol.iterator] 속성을 가지는 컬렉션 전용\r\n\r\n```jsx\r\nObject.prototype.objCustom = function () {};\r\nArray.prototype.arrCustom = function () {};\r\n\r\nvar iterable = [2, 0, 2, 1];\r\niterable.name = \"jiwoong\";\r\n\r\nfor (let key in iterable) {\r\n  console.log(key); // 0, 1, 2, 3, \"name\", \"arrCustom\", \"objCustom\"\r\n}\r\n\r\nfor (let value of iterable) {\r\n  console.log(value); // 2, 0, 2, 1\r\n}\r\n```","excerpt":"들어가기 앞서 자바스크립트의 반복문에는 크게 for 문, foreach 문, for...in 문, for...of문 등이 있습니다. 이 반복문들의 특징과 차이점에 대해서 알아보려고 합니다. for 문 for 반복문 일반적인 반복문입니다. foreac…","fields":{"slug":"/210317-post/"},"frontmatter":{"date":"Mar 17, 2021","title":"자바스크립트 반복문","tags":["자바스크립트"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## 📖 문제\r\n\r\n```\r\n7개의 자연수가 주어질 때, 이들 중 홀수인 자연수들을 모두 골라 그 합을 구하고, 고른 홀수들\r\n중 최소값을 찾는 프로그램을 작성하세요.\r\n예를 들어, 7개의 자연수 12, 77, 38, 41, 53, 92, 85가 주어지면 이들 중 홀수는 77, 41, 53,\r\n85이므로 그 합은\r\n\r\n77 + 41 + 53 + 85\r\n\r\n이 되고,\r\n\r\n41 < 53 < 77 < 85\r\n\r\n이므로 홀수들 중 최소값은 41이 된다.\r\n\r\n💬 입력설명\r\n\r\n첫 번째 줄에 자연수 7개가 주어진다. 주어지는 자연수는 100보다 작다. 홀수가 한 개 이상\r\n반드시 존재한다.\r\n\r\n💬 출력설명\r\n\r\n첫째 줄에 홀수들의 합을 출력하고, 둘째 줄에 홀수들 중 최소값을 출력한다.\r\n\r\n💬 입력예제 1\r\n\r\n12 77 38 41 53 92 85\r\n\r\n💬 출력예제 1\r\n\r\n256  41\r\n\r\n출처 : 한국정보올림피아드\r\n```\r\n\r\n## 📖 풀이\r\n\r\n### 최초 풀이\r\n\r\n```jsx\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>출력결과</title>\r\n  </head>\r\n  <body>\r\n    <script>\r\n      function solution(arr) {\r\n        let answer = [];\r\n        let sum = 0;\r\n        let min = 1000;\r\n\r\n        odd_arr = [];\r\n        for (let i = 0; i < arr.length; i++) {\r\n          if (arr[i] % 2 != 0) odd_arr.push(arr[i]);\r\n        }\r\n\r\n        for (let i = 0; i < odd_arr.length; i++) {\r\n          sum = sum + odd_arr[i];\r\n\r\n          if (min > odd_arr[i]) min = odd_arr[i];\r\n        }\r\n\r\n        answer.push(sum);\r\n        answer.push(min);\r\n\r\n        return answer;\r\n      }\r\n\r\n      arr = [12, 77, 38, 41, 53, 92, 85];\r\n      console.log(solution(arr));\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\nfor문을 사용해서 odd_arr 배열에 홀수들을 담아두고,\r\n\r\nodd_arr 배열을 for문을 사용해서 sum 값과 min 값을 계산하였습니다.\r\n\r\n### 개선 [시간 효율 고려]\r\n\r\n```jsx\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>출력결과</title>\r\n  </head>\r\n  <body>\r\n    <script>\r\n      function solution(arr) {\r\n        let answer = [];\r\n        let sum = 0;\r\n        let min = 1000;\r\n\r\n        odd_arr = [];\r\n        for (let i = 0; i < arr.length; i++) {\r\n          if (arr[i] % 2 === 1) {\r\n            sum += arr[i];\r\n\r\n            if (min > arr[i]) min = arr[i];\r\n          }\r\n        }\r\n\r\n        answer.push(sum);\r\n        answer.push(min);\r\n\r\n        return answer;\r\n      }\r\n\r\n      arr = [12, 77, 38, 41, 53, 92, 85];\r\n      console.log(solution(arr));\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n홀수들을 따로 담는 배열을 만들지 않고, 바로 홀수를 체크하는 for문에서 값들을 대입해주었습니다.  \r\n\r\n홀수를 따로 담고, 배열에 담아서 그 배열을 또 for문을 돌리는 것 자체가 일을 한번 더 하는 것이라 시간을 고려했을 때 비효율적인 코드인 것 같다고 의문이 들었습니다.  \r\n\r\n평소 항상 판별한 데이터들을 담아두고, 담아둔 데이터에서 가져가다 쓰는 방식이 습관화 되서 그런 것 같습니다.  하지만, 어느것이 맞고, 어느것이 틀리다기 보단 상황에 맞게 쓰는 것이 좋다고 생각됩니다.\r\n\r\n그리고 일반적인  for문 대신에 foreach, for-in, for-of 를 사용해서 코드를 간결화 시키면 좋을거란 생각이 들었습니다.  \r\n\r\n다음 포스팅에서는 foreach, for ... in, for ... of 의 특징 및 차이점에 대해서 알아보겠습니다.","excerpt":"📖 문제 📖 풀이 최초 풀이 for문을 사용해서 odd_arr 배열에 홀수들을 담아두고, odd_arr 배열을 for문을 사용해서 sum 값과 min 값을 계산하였습니다. 개선 시간 효율 고려 홀수들을 따로 담는 배열을 만들지 않고, 바로 홀수를 체…","fields":{"slug":"/210316-post/"},"frontmatter":{"date":"Mar 16, 2021","title":"홀수 [자바스크립트 알고리즘]","tags":["자바스크립트","알고리즘"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n![js](../img/js.jpg)\r\n\r\n## 들어가기\r\n\r\n개인적으로 코딩 컨밴션을 중요하게 생각하는 편입니다.\r\n변수명, 함수명 등을 통일된 네이밍으로 사용하는 습관이 필요하다고 생각합니다.\r\n이 습관은 자신의 코드를 나와 다른 이들이 볼 때 조금 더 빠르고 직관적이게 이해할 수 있는데 도움이 된다고 생각합니다.\r\n그래서 자바스크립트를 깊숙히 들어가기 앞서, 코딩 컨밴션에 대해서 알아보려고 합니다.\r\n\r\n## 네이밍 기본\r\n\r\n- **단일 글자**로 이름을 짓지 않고 이름을 통해 쓰임새를 알 수 있도록 한다.\r\n\r\n    ```jsx\r\n    // bad\r\n    function q() {\r\n      // ...\r\n    }\r\n\r\n    // good\r\n    function query() {\r\n      // ...\r\n    }\r\n    ```\r\n\r\n- 이름의 맨 앞이나 맨 뒤쪽에 **밑줄( _ )**을 사용하지 않는다.\r\n\r\n    ```jsx\r\n    // bad\r\n    this.__firstName__ = 'Panda';\r\n    this.firstName_ = 'Panda';\r\n    this._firstName = 'Panda';\r\n\r\n    // good\r\n    this.firstName = 'Panda';\r\n    ```\r\n\r\n- **this**를 변수의 값으로 사용하지 않는다. 필요하다면 **화살표 함수(Arrow Function)**이나 **바인딩**을 사용하라.\r\n\r\n    ```jsx\r\n    // bad\r\n    function foo() {\r\n      const self = this;\r\n      return function () {\r\n        console.log(self);\r\n      };\r\n    }\r\n\r\n    // good\r\n    function bar() {\r\n      return () => {\r\n        console.log(this);\r\n      };\r\n    }\r\n    ```\r\n\r\n- 가독성을 위해 약어는 **모두 대문자** 혹은 **모두 소문자**로 표기한다.\r\n\r\n    ```jsx\r\n    // bad\r\n    import SmsContainer from './containers/SmsContainer';\r\n\r\n    // bad\r\n    const HttpRequests = [\r\n      // ...\r\n    ];\r\n\r\n    // good\r\n    import SMSContainer from './containers/SMSContainer';\r\n\r\n    // good\r\n    const HTTPRequests = [\r\n      // ...\r\n    ];\r\n\r\n    // also good\r\n    const httpRequests = [\r\n      // ...\r\n    ];\r\n\r\n    // best\r\n    import TextMessageContainer from './containers/TextMessageContainer';\r\n\r\n    // best\r\n    const requests = [\r\n      // ...\r\n    ];\r\n    ```\r\n\r\n- export되는 파일 내의 모든 상수는 **모두 대문자**로 표기한다.\r\n\r\n    ```jsx\r\n    // bad\r\n    const PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file';\r\n\r\n    // bad\r\n    export const THING_TO_BE_CHANGED = 'should obviously not be uppercased';\r\n\r\n    // bad\r\n    export let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables';\r\n\r\n    // ---\r\n\r\n    // allowed but does not supply semantic value\r\n    export const apiKey = 'SOMEKEY';\r\n\r\n    // better in most cases\r\n    export const API_KEY = 'SOMEKEY';\r\n\r\n    // ---\r\n\r\n    // bad - unnecessarily uppercases key while adding no semantic value\r\n    export const MAPPING = {\r\n      KEY: 'value'\r\n    };\r\n\r\n    // good\r\n    export const MAPPING = {\r\n      key: 'value'\r\n    };\r\n    ```\r\n\r\n- 이름에 복수형을 표기하지 않는다.\r\n\r\n    ```jsx\r\n    //bad\r\n    let delivery_notes = [\"one\", \"two\"];\r\n\r\n    // good\r\n    let delivery_note_list = [\"one\", \"two\"];\r\n    ```\r\n\r\n- 줄일말을 사용하지 않는다.\r\n\r\n    ```jsx\r\n    //bad\r\n    let del_note = 1;\r\n\r\n    // good\r\n    let delivery_note = 1;\r\n    ```\r\n\r\n## 파일 및 패키지\r\n\r\n- 파일의 이름은 소문자로 표기한다.\r\n\r\n    ```jsx\r\n    // bad\r\n    LonDon.png\r\n    HELLOWORLD.pdf\r\n    APP.js\r\n\r\n    // good\r\n    london.png\r\n    helloworld.pdf\r\n    app.js\r\n    ```\r\n\r\n- 패키지의 이름은 **lowerCamelCase**로 표기한다.\r\n\r\n    ```jsx\r\n    // bad\r\n    my.examplecode.deepspace\r\n    my.example_code.deep_space\r\n\r\n    // good\r\n    my.exampleCode.deepSpace\r\n    ```\r\n\r\n- 파일의 이름은 **default export의 이름**과 일치해야한다.\r\n\r\n    ```jsx\r\n    // file 1 contents\r\n    class CheckBox {\r\n      // ...\r\n    }\r\n    export default CheckBox;\r\n\r\n    // file 2 contents\r\n    export default function fortyTwo() { return 42; }\r\n\r\n    // file 3 contents\r\n    export default function insideDirectory() {}\r\n\r\n    // in some other file\r\n    // bad\r\n    import CheckBox from './checkBox'; // PascalCase import/export, camelCase filename\r\n    import FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase export\r\n    import InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export\r\n\r\n    // bad\r\n    import CheckBox from './check_box'; // PascalCase import/export, snake_case filename\r\n    import forty_two from './forty_two'; // snake_case import/filename, camelCase export\r\n    import inside_directory from './inside_directory'; // snake_case import, camelCase export\r\n    import index from './inside_directory/index'; // requiring the index file explicitly\r\n    import insideDirectory from './insideDirectory/index'; // requiring the index file explicitly\r\n\r\n    // good\r\n    import CheckBox from './CheckBox'; // PascalCase export/import/filename\r\n    import fortyTwo from './fortyTwo'; // camelCase export/import/filename\r\n    import insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit \"index\"\r\n    // ^ supports both insideDirectory.js and insideDirectory/index.js\r\n    ```\r\n\r\n## 변수\r\n\r\n- 변수의 이름은 **lowerCamelCase**로 표기한다.단, export되는 파일 내의 상수는 예외.\r\n- 변수의 이름은 **알파벳**으로 시작해야한다.\r\n\r\n    ```jsx\r\n    // bad\r\n    let 123Number = 123;\r\n    let HELLO_WORLD = \"Hello World\";\r\n\r\n    // good\r\n    let number = 369;\r\n    let helloString = \"Hello World\";\r\n    ```\r\n\r\n# 함수\r\n\r\n- 함수는 **lowerCamelCase**로 표기한다.\r\n\r\n    ```jsx\r\n    // bad\r\n    function MyFunction() {...}\r\n\r\n    // good\r\n    function myFunction() {...}\r\n    ```\r\n\r\n- 함수의 이름은 동사 또는 동사구문으로 표기한다.\r\n\r\n    ```jsx\r\n    // bad\r\n    function whereIsCamera() { ... }\r\n\r\n    // good\r\n    function findCamera() { ... }\r\n    function getFoo() { ... } // getter\r\n    function setBar() { ... } // setter\r\n    function hasCoo() { ... } // booleans\r\n    ```\r\n\r\n- 함수를 default export할 때는 **camelCase**로 표기한다.단, 함수의 이름이 파일의 이름과 구분되어야 한다.\r\n\r\n    ```jsx\r\n    function makeStyleGuide() {\r\n      // ...\r\n    }\r\n\r\n    export default makeStyleGuide;\r\n    ```\r\n\r\n- 함수 라이브러리를 export할 때는 **PascalCase**로 표기한다.\r\n- 함수의 파라미터는 **lowerCamelCase**로 표기한다.단, 한글자의 파라미터는 public 메소드에서는 사용하지 않는다.\r\n\r\n    ```jsx\r\n    // bad\r\n    function someFunction(SOMEVALUE, SOMEARRAY) { ... }\r\n\r\n    // good\r\n    function someFunction(someValue, someArray) { ... }\r\n    ```\r\n\r\n- 템플릿 함수의 파라미터는 모두 간결해야하고 **한글자** 또는 **한단어**여야 한다.또, **모두 대문자**로 표기한다.\r\n\r\n## 객체\r\n\r\n- 객체의 이름은 **lowerCamelCase**로 표기한다.\r\n\r\n    ```jsx\r\n    // bad\r\n    const OBJEcttsssss = {};\r\n    const this_is_my_object = {};\r\n    function c() {}\r\n\r\n    // good\r\n    const thisIsMyObject = {};\r\n    function thisIsMyFunction() {}\r\n    ```\r\n\r\n- 객체를 export할 때는 **PascalCase**로 표기한다.\r\n\r\n    ```jsx\r\n    const AirbnbStyleGuide = {\r\n      es6: {\r\n      },\r\n    };\r\n\r\n    export default AirbnbStyleGuide;\r\n    ```\r\n\r\n## 클래스\r\n\r\n- 클래스나 생성자의 이름은 **PascalCase**로 표기한다.\r\n\r\n    ```jsx\r\n    // bad\r\n    function user(options) {\r\n      this.name = options.name;\r\n    }\r\n\r\n    const bad = new user({\r\n      name: 'nope',\r\n    });\r\n\r\n    // good\r\n    class User {\r\n      constructor(options) {\r\n        this.name = options.name;\r\n      }\r\n    }\r\n\r\n    const good = new User({\r\n      name: 'yup',\r\n    });\r\n    ```\r\n\r\n- 클래스의 이름은 **명사** 또는 **명사구문**으로 표기한다.또한, 인터페이스의 경우 명사 대신 **형용사** 또는 **형용사구문**으로 표기할 수 있다.\r\n- 클래스를 export할 때는 **PascalCase**로 표기한다.","excerpt":"들어가기 개인적으로 코딩 컨밴션을 중요하게 생각하는 편입니다.\n변수명, 함수명 등을 통일된 네이밍으로 사용하는 습관이 필요하다고 생각합니다.\n이 습관은 자신의 코드를 나와 다른 이들이 볼 때 조금 더 빠르고 직관적이게 이해할 수 있는데 도움이 된다고…","fields":{"slug":"/210315-post/"},"frontmatter":{"date":"Mar 15, 2021","title":"자바스크립트 코딩 컨밴션","tags":["자바스크립트","코딩컨밴션"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## 📖 Git bash 기본 명령어\r\n\r\n### Git 초기화\r\n\r\n```bash\r\ngit init\r\n```\r\n\r\nGit 초기화를 하면 .git이라는 숨겨진 폴더가 만들어진다. 이것이 로컬 저장소\r\n\r\n로컷 저장소에 내가 만든 버전 정보, 원격 저장소 주소 등이 저장된다.\r\n\r\n원격 저장소에서 내 컴퓨터로 코드를 받아오면 로컬 저장소가 자동으로 생긴다.\r\n\r\n### Git 사용자 정보 등록\r\n\r\n```bash\r\ngit config --global user.name \"Jiwoong Oh\"\r\ngit config --global user.email ojiwoong@gmail.com\r\n```\r\n\r\nGit 커밋 시에 등록할 사용자 정보(이름, 이메일) 등록 \r\n\r\n### Git 원하는 파일 선택\r\n\r\n```bash\r\ngit add index.html\r\n```\r\n\r\n커밋할 파일 선택\r\n\r\n### Git 커밋 메세지를 달아 커밋 생성\r\n\r\n```bash\r\ngit commit -m \"첫번째 커밋\"\r\n```\r\n\r\n커밋메시지 입력\r\n\r\n### 생성한 커밋 히스토리 보기\r\n\r\n```bash\r\ngit log\r\n```\r\n\r\n### 로컬저장소에 GitHub 저장소 연동\r\n\r\n```bash\r\ngit remote add origin https://github.com/ojiwoong/First_Website.git\r\n```\r\n\r\n연동할 저장소 주소 입력\r\n\r\n### 커밋 파일 원격저장소에 저장\r\n\r\n```bash\r\ngit push origin maste\r\n```\r\n\r\n### 원격저장소의 전체파일 로컬저장소에 가져오기\r\n\r\n```bash\r\ngit clone https://github.com/ojiwoong/First_Website.git .\r\n```\r\n\r\n클론할 저장소 주소 입력\r\n\r\n.[점]을 입력해야 현재 폴더에 클론, 미입력 시 새 폴더 생성 및 클론\r\n\r\n### 원격저장소의 변경사항 로컬저장소에 가져오기\r\n\r\n```bash\r\ngit pull origin master\r\n```\r\n\r\n## 📖 유용한 Git 기능들\r\n\r\n### Amend [고치다]\r\n\r\n방금 만든 마지막 커밋에 새로운 내용 추가\r\n\r\n이미 커밋 받은 사람이 있으면 커밋 히스토리가 꼬이기 때문에, 개별적으로 사용하는 브랜치에서만\r\n\r\n주의해서 사용해야함\r\n\r\n### Stash [숨기는 장소]\r\n\r\n작업중이던 파일을 임시로 저장\r\n\r\n### Reset [초기화]\r\n\r\n특정 커밋 히스토리로 되돌림\r\n\r\norigin/master 브랜치도 리셋된 버전으로 변경하기 위해서는 force push [강제푸쉬]를 사용해야 함.\r\n\r\nforce push도 개별적으로 사용하는 브랜치에서만 주의해서 사용해야함.\r\n\r\n[[Reset 명확히 알고가기]](https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-Reset-%EB%AA%85%ED%99%95%ED%9E%88-%EC%95%8C%EA%B3%A0-%EA%B0%80%EA%B8%B0)\r\n\r\n### Revert [되돌림]\r\n\r\n특정 커밋 변경사항을 되돌림\r\n\r\n특정 커밋 히스토리로 되돌아가는 것이 아니라, 새로운 커밋으로 변경사항을 되돌림.\r\n\r\n### Cherry-pick\r\n\r\n다른 별개의 브랜치에서 한 작업의 특정 커밋의 변경사항만 똑 떼서 가져와 커밋\r\n\r\n## 📖 Git 추가 명령어\r\n\r\n```bash\r\ngit init\r\n# 리포지토리 초기화. '.git'폴더 생성. 이 폴더에 현재 폴더와 관련된 관리 정보가 저장. working tree라고 부른다. 변경 내역 등 관리.\r\n\r\ngit status\r\n# 리포지토리 상태 표시. \r\n\r\ngit add 파일명\r\n# 스테이지 영역(커밋 전 임시 영역)에 파일 추가. \r\n\r\ngit commit -m '첫 커밋'\r\n# 스테이지 영역에 기록된 시점들 파일을 실제 리포지토리 변경 내역에 반영.\r\n\r\ngit log\r\n# 리포지토리에 커밋된 로그 확인. \r\n\r\ngit log --pretty=short\r\n# 로그 확인시 첫 번째 요약 줄만 보여주기\r\n\r\ngit log README.md\r\n# 리드미 관련된 로그만 보기 (폴더 명도 가능)\r\n\r\ngit log -p\r\n# 커밋에서 변경된 내용 함께 확인. (뒤에 파일/폴더명 붙여도 됨)\r\n\r\ngit diff\r\n# working tree, 스테이지 영역, 최신 커밋 사이 변경 확인\r\n\r\ngit diff HEAD\r\n# 최신 commit과의 차이 확인\r\n\r\ngit branch\r\n# 브랜치 목록 표시, 현재 어떤 브랜치인지.\r\n\r\ngit checkout -b 'feature-A'\r\n# feature-A 이름의 브랜치 만들고 그 브랜치로 이동\r\n\r\ngit merge --no--ff feature-A\r\n# 현재 브랜치에서 feature-A브랜치를 머지. 옵션은 머지 커밋도 함께 남기고 싶다는 뜻.\r\n\r\ngit log --graph\r\n# 브랜치를 시각적으로 확인\r\n\r\ngit reset --hard 커밋해시값\r\n# HEAD, 스테이지, Working tree를 특정 커밋으로 복원.\r\n\r\ngit reflog\r\n# 현재 브랜치 뿐만이 아니라 이 리포지토리에서 진행된 모든 로그 볼 수 있음\r\n\r\ngit commit --amend\r\n# 바로 전에 작성했던 커밋 메세지 수정\r\n\r\ngit commit -am \"바로 애드하고 커밋하고 싶당\"\r\n# add, commit 한번에 하기\r\n\r\n> git rebase -i HEAD~2\r\npick 7a34294 Add feature-C\r\npick 6fsdfa2 Fix typo\r\n# 현재 브랜치의 HEAD(최신 commit)를 포함한 두 개의 변경 내역과 관련된 내용 보여짐. 이 두개를 합쳐 한 커밋으로 뭉개버리고 싶다. fix typo가 부끄러우니까!\r\n\r\npick 7a34294 Add feature-C\r\nfixup 6fsdfa2 Fix typo\r\n# 뭉개고 싶은 커밋에 'fixup'으로 고쳐주고 저장. \r\n\r\ngit remote add origin git@github.com:사용자명/저장소이름.git\r\n# 주소의 저장소를 원격 저장소로 설정\r\n\r\ngit push -u origin master\r\n# -u옵션: 로컬 리포에 있는 현재 브랜치 upstream이 origin 리포의 master 브랜치로 설정.\r\n\r\ngit push -u origin feature-D\r\n# 원격의 feature-D브랜치로 push\r\n\r\ngit clone git@github....git\r\n# 주소의 리포지토리 받아오기\r\n\r\ngit branch -a\r\n# 로컬 리포지토리랑 원격 리포지토리 브랜치 모두 표시\r\n\r\ngit checkout -b feature-D origin/feature-D\r\n# 원격의 feature-D리포를 내가 새로 만든 feature-D브랜치로 체크아웃\r\n```\r\n\r\n## 📖 커밋 메시지 기본양식\r\n1째 줄 : 변경 내용 한 줄 요약  \r\n2째 줄 : 공백  \r\n3째 줄 부터 : 변경과 관련 내용 상세 기록\r\n","excerpt":"📖 Git bash 기본 명령어 Git 초기화 Git 초기화를 하면 .git이라는 숨겨진 폴더가 만들어진다. 이것이 로컬 저장소 로컷 저장소에 내가 만든 버전 정보, 원격 저장소 주소 등이 저장된다. 원격 저장소에서 내 컴퓨터로 코드를 받아오면 로컬…","fields":{"slug":"/first-post/"},"frontmatter":{"date":"Mar 15, 2021","title":"Git 사용법","tags":["git"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}