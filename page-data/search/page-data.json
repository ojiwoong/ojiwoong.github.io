{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n## 들어가며\r\n자바스크립트라는 언어를 배우기전에 언어에 대한 더 깊숙한 이해를 위해 탄생배경에 대해서 알아보았습니다.\r\n궁금할 때마다, 글로 읽어보기 위해 드림코딩의 엘리님의 유튜브 영상내용을 글로 옮겨서 적었습니다.  \r\n[[자바스크립트의 역사와 현재 그리고 미래]](https://www.youtube.com/watch?v=wcsVjmHrUQg&list=PLv2d7VI9OotTVOL4QmPfvJWPJvkmv6h-2)\r\n\r\n## 자바스크립트의 역사\r\n1993년도 Mosaic Web Browser가 시장에 나오게 됩니다.\r\n\r\nMosaic Web Browser 개발 리더인 Marc Andreessen 대학교 졸업함과 동시에 Netscape 회사 설립하게 됩니다.\r\n\r\n1994년 Mosaic Web Browser의 경험을 토대로 해서 조금 더 UI가 더해진 Netscape Navigator를 시장에 내게 됩니다.\r\n\r\nNetscape Navigator는 80%의 점유율을 자랑하면서 급격하게 성장하게 됩니다.\r\n\r\nMarc Andreessen는 동적인 웹사이트를 어떻게 만들 수 있을까 고민하게 되고, Scripting 언어를 추가하자는 생각을 하게 됩니다.\r\n\r\n처음으로 고려되었던 언어는 Sun Microsystems 사의 자바언어였지만, 웹 사이트를 주로 개발하던 개발자들이 쓰기에는 다소 어려웠습니다.\r\n\r\n두번째 방법으로, Brendan Eich 란 사람을 스카웃 해와서, 기존에 존재했던 Scheme을 조금 변형하도록 합니다.\r\n\r\nBrendan Eich 에게 10일만에 언어를 만들어보자하고, 정말 짧은 시간 안에 프로토타입을 베이스로 한 유연한 언어를 개발하게 됩니다.\r\n\r\n1994년도 9월 내부적으로 Mocha 라고 불리는 언어가 새로 탄생하게 됩니다. 이후에 LiveScript로 이름이 바뀌게 되고, Netscape Navigator 안에는 LiveScript를 실행하고 이해할 수 있는 LiveScript 엔진인 InterPreter가 포함이 되어서 브라우저가 출시되게 됩니다.\r\n\r\n그리고, 그 당시에 자바언어의 인기가 치솟고 있었고, Netscape 사는 자바의 인기에 조금이라도 얹혀가기 위해서 LiveScript 란 이름을 JavaScript로 변경하게 됩니다.\r\n \r\n 1995년에 공식적으로 Netscape Navigator에 JavaScript 와 엔진이 포함되어서 브라우저가 출시되게 됩니다.\r\n\r\n 이러한 Netscape 사의 성공경험을 목격하고, 이 브라우저의 잠재성을 확인한 Microsoft 사는 Netscape 사에서 출시한 브라우저를 리버스엔지니어링을 하게 됩니다.\r\n\r\n 이 리버스 엔지니어링은 만들어진 프로그램의 binary로 이루어진 소스코드를 그대로 복원하게 됩니다.\r\nMicrosoft 사는 JavaScript 를 그대로 배껴와서 조금만 기능을 변경해서 자신들만의 언어인척 JScript 란 언어를 만들게 됩니다.\r\n\r\n그렇게, 1995년에 Microsoft 사도 Internet Explorer 라는 브라우저를 시장에 내놓게 됩니다.\r\n\r\n그리고 이것은 개발자들 고통의 시발점이 되게 됩니다. 웹 개발자들은 너무나 다른 2개의 브라우저 위에 모두 잘 동작할 수 있는 웹사이트를 만들어야 했습니다. \r\n이 사태로 인해, 사이트마다 \"이 사이트는 Netscape Navigator 혹은 Internet Explorer 에서 호환이 잘되니 이 브라우저를 다운로드 받으세요\" 란 문구가 빈번하게 사용되게 됩니다.\r\n\r\n이 사태를 도저히 참지 못한 Netscape 사는 ECMA International 단체를 찾아가서 표준화를 만들어보자는 제안을 하게 됩니다.\r\n\r\n이로 인해, 1997년 7월에 첫번째 ECMAScript 1 이 시장에 나오게 됩니다.\r\n이 ECMAScript는 브라우저에 동작하는 언어를 만들 때, 그리고 그 언어를 이해할 수 있는 엔진이 이해하기 위한 문법적인 사항을 잘 정리한 문서입니다.\r\n\r\n그리고, 그 이후에 새로운 버전들이 계속 추가되며, 버전업 되면서 다양한 문법 등이 추가되며, 다양한 아이디어들이 제안되게 됩니다.\r\n이렇게 많은 것들이 논의되는 동안 2000년도에 Internet Explorer 시장은 급격하게 성장하게 됩니다. 무려 95%의 시장 점유율을 확보하게 되고, 조금씩 건방져지게 되고, ECMAScript 의 문법들이 추가되는 방식이 마음에 들지않아, 사용자가 가장 많은 자신들이 표준이며, 점차 ECMAScript의 표준안에 참가하지 않게 됩니다.\r\n\r\n이로 인해, 2000년도부터 표준안 진행이 더뎌지게 됩니다.\r\n\r\n이후 4년뒤인, 2004년도에 Mozila 사의 Firefox 브라우저가 등장하게 됩니다. Mozila 사는 ECMAScript 사에 찾아가서 ActionScript 란 언어와 이를 이해하는 엔진인 Tamarin을 가지고 다시 표준화를 검토해보자고 제안을 하게 됩니다.\r\n하지만 ActionScript 와 Tamarin 은 기존에 브라우저에 쓰이고 있는 JScript 와 JavaScript 와는 너무나 달랐기 때문에, 다시 표준화를 진행하는데는 무리가 있었습니다.\r\n\r\n그래서, 표준안을 두고 3 사의 치열한 신경전이 계속 벌어지고 있었습니다.\r\n그러는동안, 이러한 시장에 존재하는 다양한 브라우저에서 작동하는 웹사이트 만드느라, 밤에 잠도 못자고 고생하면서 웹사이트를 만들어나가야만 했습니다.\r\n\r\n그리고, 2004년에 웹 시장에서는 굉장히 획기적인 일이 발생하게 됩니다.\r\nJesse James Garrett 는 AJAX 라는 기술 명세서를 제출합니다. AJAX는 Asynchronous JavaScript and XML이며, 비동기적으로 데이터를 서버와 통신하고 처리할 수 정말 획기적인 AJAX가 도입하게 됩니다.\r\n\r\n이러한, AJAX의 도입해도 불구하고 ECMAScript 표준안을 앞두고, 3 사의 치열한 신경전은 계속 되고, 그러는동안 시장에는 새로운 브라우저인 오페라 브라우저나 다른 브라우저들이 많이 출시되게 됩니다.\r\n\r\n이로 인해, 더 다양한 웹 브라우저에 맞는 웹사이트를 만들어야 했고, 더 많은 개발자들이 웹 시장에 들어오게 됩니다.\r\n그리고, 이런 많은 개발자들 사이에서 강력한 커뮤니티가 생성되게 됩니다.\r\n이러한, 커뮤니티 사이에서 JQuery, dojo, mootools 와 같은 많은 라이브러리들이 등장하게 됩니다.\r\n\r\n이러한 라이브러리들이 해결하고자 하는 공통적인 문제점은 개발자들이 다른 브라우저의 구현사항에 신경쓰지 않도록 만드는 것이었습니다.\r\n\r\n라이브러리 중에서도 write less, do more 이라고 강조하는 JQuery 가 많은 사랑을 받게 됩니다.\r\n\r\n웹 시장을 급격하게 바꾸는 정말 진취적인 사건이 발생하게 됩니다.\r\n이것은 바로, 2008년도에 Google에서 Chrome 브라우저를 출시하게 됩니다.\r\n이 Chrome 브라우저는 Just-in-time compilation(JIT) 라는 굉장히 강력한 엔진이 포함된 브라우저입니다.\r\n이 엔진은 JavaScript 를 실행하는 속도가 엄청 빠른 강력한 엔진입니다.\r\n이러한 성능 좋은 Chrome 브라우저의 등장으로 다른 브라우저 사들은 좋은 자극을 받게 됩니다.\r\n\r\n그래서 드디어, 2008년도 7월에 모든 브라우저 사들이 모여서 생산적인 대화들을 하게 됩니다.\r\n그리하여 2009년도에 ECMAScript5 가 나오게 되고, 그 이후 2015년에 ECMAScript6 가 나오게 됩니다.\r\n그 이후에, 매해마다 ECMAScript6,7,8,9,10.... 등 새로운 버전들이 나오고 있지만, 약간의 변화만 있을 뿐이지, 거의 커다란 변화들은 5와 6에서 모두 정의되었습니다.\r\n\r\n그리고, 이제는 모든 브라우저들이 ECMAScript 의 표준사항을 잘 따라가고 있기 때문에, JQuery와 같은 라이브러리의 도움 없이, JavaSciprt(ECMAScript)만으로도 잘 동작하는 웹사이트를 만들 수 있게 됩니다.\r\n","excerpt":"들어가며 자바스크립트라는 언어를 배우기전에 언어에 대한 더 깊숙한 이해를 위해 탄생배경에 대해서 알아보았습니다.\n궁금할 때마다, 글로 읽어보기 위해 드림코딩의 엘리님의 유튜브 영상내용을 글로 옮겨서 적었습니다. [자바스크립트의 역사와 현재 그리고 미…","fields":{"slug":"/210329-post/"},"frontmatter":{"date":"Mar 29, 2021","title":"자바스크립트의 역사","tags":["자바스크립트"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n![js](../img/js.png)\r\n\r\n## 들어가며\r\n자바스크립트의 반복문에는 크게 for 문, foreach 문, for...in 문, for...of문 등이 있습니다.  \r\n이 반복문들의 특징과 차이점에 대해서 알아보려고 합니다.\r\n\r\n## for 문\r\nfor 문 일반적인 반복문입니다.\r\n\r\n```jsx\r\nlet arr = [\"오\", \"지\", \"웅\"];\r\nfor (let i = 0; i < arr.length; i++) {\r\n  console.log(arr[i]); // 오, 지, 웅\r\n}\r\n```\r\n\r\n## foreach 문\r\n\r\nforeach 문은 Array 객체에서 사용할 수 있는 메서드입니다.  \r\n(ES6부터는 Map,Set 에서도 지원한다고 합니다.)  \r\n배열의 요소들을 반복하며, callback 함수를 등록할 수 있고, 배열의 각 요소들이 반복될 때 이 clalback 함수가 호출됩니다. \r\n\r\n```jsx\r\nlet arr = [\"오\", \"지\", \"웅\"];\r\narr.forEach(function (item, index, arr2) {\r\n  console.log(item, index, arr2); // 오 0 arr, 지 1 arr, 웅 2 arr\r\n});\r\n```\r\n\r\n##for...in 문\r\n\r\n객체에 사용할 수 있으며, 객체의 key값과 value값을 가져오는데 유용합니다.  \r\n객체의 키값의 개수만큼 반복합니다.  \r\n\r\nfor...in은 객체의 반복을 위해 만들어졌지만, 배열의 반역을 위해서는 추천하지 않습니다.  \r\n이미 Array.prototype.forEach(), for...of 문이 존재합니다.\r\n\r\n객체의 속성을 확인할 수 있기 때문에, 실질적으로 디버깅을 위해 사용되거나, 특정 키가 있는지 확인할 때 주로 사용할 수 있습니다.\r\n\r\n```jsx\r\nvar obj = {\r\n  one: \"오\",\r\n  two: \"지\",\r\n  three: \"웅\",\r\n};\r\n\r\nfor (var key in obj) {\r\n  console.log(key, obj[key]); // one 오, two 지, three 웅\r\n}\r\n```\r\n\r\n##for...of 문\r\n\r\nfor of 반복문은 ES6에 추가된 새로운 컬렉션 반복문입니다.  \r\nfor of 구문을 사용하기 위해선 컬렉션 객체가 [Symbol.iterator] 속성을 가지고 있어야만 합니다.  \r\nInternet Explorer에서는 지원하지 않아, 크로스 브라우저를 고려할때는 사용에 유의해야 합니다.\r\n\r\n```jsx\r\nvar iterable = [2, 0, 2, 1]\r\n\r\nfor (var value in iterable) {\r\n  console.log(key, obj[key]); // 2, 0, 2, 1\r\n}\r\n```\r\n\r\n## for...in 문 과 for...of 문의 차이점\r\n\r\nfor...in 문 : 객체의 모든 열거 가능한 속성(property)에 대한 반복  \r\nfor...of 문 : [symbol.iterator] 속성을 가지는 컬렉션 전용\r\n\r\n```jsx\r\nObject.prototype.objCustom = function () {};\r\nArray.prototype.arrCustom = function () {};\r\n\r\nvar iterable = [2, 0, 2, 1];\r\niterable.name = \"jiwoong\";\r\n\r\nfor (let key in iterable) {\r\n  console.log(key); // 0, 1, 2, 3, \"name\", \"arrCustom\", \"objCustom\"\r\n}\r\n\r\nfor (let value of iterable) {\r\n  console.log(value); // 2, 0, 2, 1\r\n}\r\n```","excerpt":"들어가며 자바스크립트의 반복문에는 크게 for 문, foreach 문, for...in 문, for...of문 등이 있습니다. 이 반복문들의 특징과 차이점에 대해서 알아보려고 합니다. for 문 for 문 일반적인 반복문입니다. foreach 문 f…","fields":{"slug":"/210317-post/"},"frontmatter":{"date":"Mar 17, 2021","title":"자바스크립트 반복문","tags":["자바스크립트"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## 📖 문제\r\n\r\n```\r\n7개의 자연수가 주어질 때, 이들 중 홀수인 자연수들을 모두 골라 그 합을 구하고, 고른 홀수들\r\n중 최소값을 찾는 프로그램을 작성하세요.\r\n예를 들어, 7개의 자연수 12, 77, 38, 41, 53, 92, 85가 주어지면 이들 중 홀수는 77, 41, 53,\r\n85이므로 그 합은\r\n\r\n77 + 41 + 53 + 85\r\n\r\n이 되고,\r\n\r\n41 < 53 < 77 < 85\r\n\r\n이므로 홀수들 중 최소값은 41이 된다.\r\n\r\n💬 입력설명\r\n\r\n첫 번째 줄에 자연수 7개가 주어진다. 주어지는 자연수는 100보다 작다. 홀수가 한 개 이상\r\n반드시 존재한다.\r\n\r\n💬 출력설명\r\n\r\n첫째 줄에 홀수들의 합을 출력하고, 둘째 줄에 홀수들 중 최소값을 출력한다.\r\n\r\n💬 입력예제 1\r\n\r\n12 77 38 41 53 92 85\r\n\r\n💬 출력예제 1\r\n\r\n256  41\r\n\r\n출처 : 한국정보올림피아드\r\n```\r\n\r\n## 📖 풀이\r\n\r\n### 최초 풀이\r\n\r\n```jsx\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>출력결과</title>\r\n  </head>\r\n  <body>\r\n    <script>\r\n      function solution(arr) {\r\n        let answer = [];\r\n        let sum = 0;\r\n        let min = 1000;\r\n\r\n        odd_arr = [];\r\n        for (let i = 0; i < arr.length; i++) {\r\n          if (arr[i] % 2 != 0) odd_arr.push(arr[i]);\r\n        }\r\n\r\n        for (let i = 0; i < odd_arr.length; i++) {\r\n          sum = sum + odd_arr[i];\r\n\r\n          if (min > odd_arr[i]) min = odd_arr[i];\r\n        }\r\n\r\n        answer.push(sum);\r\n        answer.push(min);\r\n\r\n        return answer;\r\n      }\r\n\r\n      arr = [12, 77, 38, 41, 53, 92, 85];\r\n      console.log(solution(arr));\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\nfor문을 사용해서 odd_arr 배열에 홀수들을 담아두고,\r\n\r\nodd_arr 배열을 for문을 사용해서 sum 값과 min 값을 계산했습니다.\r\n\r\n### 개선 [시간 효율 고려]\r\n\r\n```jsx\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <title>출력결과</title>\r\n  </head>\r\n  <body>\r\n    <script>\r\n      function solution(arr) {\r\n        let answer = [];\r\n        let sum = 0;\r\n        let min = 1000;\r\n\r\n        odd_arr = [];\r\n        for (let i = 0; i < arr.length; i++) {\r\n          if (arr[i] % 2 === 1) {\r\n            sum += arr[i];\r\n\r\n            if (min > arr[i]) min = arr[i];\r\n          }\r\n        }\r\n\r\n        answer.push(sum);\r\n        answer.push(min);\r\n\r\n        return answer;\r\n      }\r\n\r\n      arr = [12, 77, 38, 41, 53, 92, 85];\r\n      console.log(solution(arr));\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n홀수들을 따로 담는 배열을 만들지 않고, 바로 홀수를 체크하는 for문에서 값들을 대입해주었습니다.\r\n\r\n홀수를 따로 담고, 배열에 담아서 그 배열을 또 for문을 돌리는 것 자체가 일을 한번 더 하는 것이라 시간을 고려했을 때 비효율적인 코드인 것 같다고 의문이 들었습니다.\r\n\r\n평소 항상 판별한 데이터들을 담아두고, 담아둔 데이터에서 가져가다 쓰는 방식이 습관화 되서 그런 것 같습니다.  하지만, 어느것이 맞고, 어느것이 틀리다기 보단 상황에 맞게 쓰는 것이 좋다고 생각합니다.\r\n\r\n그리고 일반적인  for문 대신에 foreach, for-in, for-of 를 사용해서 코드를 간결화 시키면 좋을 것 같습니다.\r\n\r\n다음 포스팅에서는 foreach, for ... in, for ... of 의 특징 및 차이점에 대해서 알아보겠습니다.","excerpt":"📖 문제 📖 풀이 최초 풀이 for문을 사용해서 odd_arr 배열에 홀수들을 담아두고, odd_arr 배열을 for문을 사용해서 sum 값과 min 값을 계산했습니다. 개선 시간 효율 고려 홀수들을 따로 담는 배열을 만들지 않고, 바로 홀수를 체크…","fields":{"slug":"/210316-post/"},"frontmatter":{"date":"Mar 16, 2021","title":"홀수 [자바스크립트 알고리즘]","tags":["자바스크립트","알고리즘"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n![js](../img/js.png)\r\n\r\n## 들어가며\r\n\r\n개인적으로 코딩 컨밴션을 중요하게 생각하는 편입니다.\r\n변수명, 함수명 등을 통일된 네이밍으로 사용하는 습관이 필요합니다.\r\n이 습관은 자신의 코드를 나와 다른 이들이 볼 때 조금 더 빠르고 직관적이게 이해할 수 있는데 도움 될 것입니다.\r\n그래서 자바스크립트를 깊숙히 들어가기 앞서, 코딩 컨밴션에 대해서 알아보려고 합니다.\r\n\r\n## 네이밍 기본\r\n\r\n- **단일 글자**로 이름을 짓지 않고 이름을 통해 쓰임새를 알 수 있도록 해야합니다.\r\n\r\n    ```jsx\r\n    // bad\r\n    function q() {\r\n      // ...\r\n    }\r\n\r\n    // good\r\n    function query() {\r\n      // ...\r\n    }\r\n    ```\r\n\r\n- 이름의 맨 앞이나 맨 뒤쪽에 **밑줄( _ )**을 사용하지 않습니다.\r\n\r\n    ```jsx\r\n    // bad\r\n    this.__firstName__ = 'Panda';\r\n    this.firstName_ = 'Panda';\r\n    this._firstName = 'Panda';\r\n\r\n    // good\r\n    this.firstName = 'Panda';\r\n    ```\r\n\r\n- **this**를 변수의 값으로 사용하지 않는다. 필요하다면 **화살표 함수(Arrow Function)**이나 **바인딩**을 사용합니다.\r\n\r\n    ```jsx\r\n    // bad\r\n    function foo() {\r\n      const self = this;\r\n      return function () {\r\n        console.log(self);\r\n      };\r\n    }\r\n\r\n    // good\r\n    function bar() {\r\n      return () => {\r\n        console.log(this);\r\n      };\r\n    }\r\n    ```\r\n\r\n- 가독성을 위해 약어는 **모두 대문자** 혹은 **모두 소문자**로 표기합니다.\r\n\r\n    ```jsx\r\n    // bad\r\n    import SmsContainer from './containers/SmsContainer';\r\n\r\n    // bad\r\n    const HttpRequests = [\r\n      // ...\r\n    ];\r\n\r\n    // good\r\n    import SMSContainer from './containers/SMSContainer';\r\n\r\n    // good\r\n    const HTTPRequests = [\r\n      // ...\r\n    ];\r\n\r\n    // also good\r\n    const httpRequests = [\r\n      // ...\r\n    ];\r\n\r\n    // best\r\n    import TextMessageContainer from './containers/TextMessageContainer';\r\n\r\n    // best\r\n    const requests = [\r\n      // ...\r\n    ];\r\n    ```\r\n\r\n- export되는 파일 내의 모든 상수는 **모두 대문자**로 표기합니다.\r\n\r\n    ```jsx\r\n    // bad\r\n    const PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file';\r\n\r\n    // bad\r\n    export const THING_TO_BE_CHANGED = 'should obviously not be uppercased';\r\n\r\n    // bad\r\n    export let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables';\r\n\r\n    // ---\r\n\r\n    // allowed but does not supply semantic value\r\n    export const apiKey = 'SOMEKEY';\r\n\r\n    // better in most cases\r\n    export const API_KEY = 'SOMEKEY';\r\n\r\n    // ---\r\n\r\n    // bad - unnecessarily uppercases key while adding no semantic value\r\n    export const MAPPING = {\r\n      KEY: 'value'\r\n    };\r\n\r\n    // good\r\n    export const MAPPING = {\r\n      key: 'value'\r\n    };\r\n    ```\r\n\r\n- 이름에 복수형을 표기하지 않습니다.\r\n\r\n    ```jsx\r\n    //bad\r\n    let delivery_notes = [\"one\", \"two\"];\r\n\r\n    // good\r\n    let delivery_note_list = [\"one\", \"two\"];\r\n    ```\r\n\r\n- 줄일말을 사용하지 않는다.\r\n\r\n    ```jsx\r\n    //bad\r\n    let del_note = 1;\r\n\r\n    // good\r\n    let delivery_note = 1;\r\n    ```\r\n\r\n## 파일 및 패키지\r\n\r\n- 파일의 이름은 소문자로 표기합니다.\r\n\r\n    ```jsx\r\n    // bad\r\n    LonDon.png\r\n    HELLOWORLD.pdf\r\n    APP.js\r\n\r\n    // good\r\n    london.png\r\n    helloworld.pdf\r\n    app.js\r\n    ```\r\n\r\n- 패키지의 이름은 **lowerCamelCase**로 표기합니다.\r\n\r\n    ```jsx\r\n    // bad\r\n    my.examplecode.deepspace\r\n    my.example_code.deep_space\r\n\r\n    // good\r\n    my.exampleCode.deepSpace\r\n    ```\r\n\r\n- 파일의 이름은 **default export의 이름**과 일치해야합니다.\r\n\r\n    ```jsx\r\n    // file 1 contents\r\n    class CheckBox {\r\n      // ...\r\n    }\r\n    export default CheckBox;\r\n\r\n    // file 2 contents\r\n    export default function fortyTwo() { return 42; }\r\n\r\n    // file 3 contents\r\n    export default function insideDirectory() {}\r\n\r\n    // in some other file\r\n    // bad\r\n    import CheckBox from './checkBox'; // PascalCase import/export, camelCase filename\r\n    import FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase export\r\n    import InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export\r\n\r\n    // bad\r\n    import CheckBox from './check_box'; // PascalCase import/export, snake_case filename\r\n    import forty_two from './forty_two'; // snake_case import/filename, camelCase export\r\n    import inside_directory from './inside_directory'; // snake_case import, camelCase export\r\n    import index from './inside_directory/index'; // requiring the index file explicitly\r\n    import insideDirectory from './insideDirectory/index'; // requiring the index file explicitly\r\n\r\n    // good\r\n    import CheckBox from './CheckBox'; // PascalCase export/import/filename\r\n    import fortyTwo from './fortyTwo'; // camelCase export/import/filename\r\n    import insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit \"index\"\r\n    // ^ supports both insideDirectory.js and insideDirectory/index.js\r\n    ```\r\n\r\n## 변수\r\n\r\n- 변수의 이름은 **lowerCamelCase**로 표기합니다.단, export되는 파일 내의 상수는 예외.\r\n- 변수의 이름은 **알파벳**으로 시작해야합니다.\r\n\r\n    ```jsx\r\n    // bad\r\n    let 123Number = 123;\r\n    let HELLO_WORLD = \"Hello World\";\r\n\r\n    // good\r\n    let number = 369;\r\n    let helloString = \"Hello World\";\r\n    ```\r\n\r\n# 함수\r\n\r\n- 함수는 **lowerCamelCase**로 표기한다.\r\n\r\n    ```jsx\r\n    // bad\r\n    function MyFunction() {...}\r\n\r\n    // good\r\n    function myFunction() {...}\r\n    ```\r\n\r\n- 함수의 이름은 동사 또는 동사구문으로 표기한다.\r\n\r\n    ```jsx\r\n    // bad\r\n    function whereIsCamera() { ... }\r\n\r\n    // good\r\n    function findCamera() { ... }\r\n    function getFoo() { ... } // getter\r\n    function setBar() { ... } // setter\r\n    function hasCoo() { ... } // booleans\r\n    ```\r\n\r\n- 함수를 default export할 때는 **camelCase**로 표기합니다..단, 함수의 이름이 파일의 이름과 구분되어야 합니다..\r\n\r\n    ```jsx\r\n    function makeStyleGuide() {\r\n      // ...\r\n    }\r\n\r\n    export default makeStyleGuide;\r\n    ```\r\n\r\n- 함수 라이브러리를 export할 때는 **PascalCase**로 표기합니다..\r\n- 함수의 파라미터는 **lowerCamelCase**로 표기합니다.단, 한글자의 파라미터는 public 메소드에서는 사용하지 않습니다..\r\n\r\n    ```jsx\r\n    // bad\r\n    function someFunction(SOMEVALUE, SOMEARRAY) { ... }\r\n\r\n    // good\r\n    function someFunction(someValue, someArray) { ... }\r\n    ```\r\n\r\n- 템플릿 함수의 파라미터는 모두 간결해야하고 **한글자** 또는 **한단어**여야 한다.또, **모두 대문자**로 표기합니다..\r\n\r\n## 객체\r\n\r\n- 객체의 이름은 **lowerCamelCase**로 표기합니다..\r\n\r\n    ```jsx\r\n    // bad\r\n    const OBJEcttsssss = {};\r\n    const this_is_my_object = {};\r\n    function c() {}\r\n\r\n    // good\r\n    const thisIsMyObject = {};\r\n    function thisIsMyFunction() {}\r\n    ```\r\n\r\n- 객체를 export할 때는 **PascalCase**로 표기합니다..\r\n\r\n    ```jsx\r\n    const AirbnbStyleGuide = {\r\n      es6: {\r\n      },\r\n    };\r\n\r\n    export default AirbnbStyleGuide;\r\n    ```\r\n\r\n## 클래스\r\n\r\n- 클래스나 생성자의 이름은 **PascalCase**로 표기합니다.\r\n\r\n    ```jsx\r\n    // bad\r\n    function user(options) {\r\n      this.name = options.name;\r\n    }\r\n\r\n    const bad = new user({\r\n      name: 'nope',\r\n    });\r\n\r\n    // good\r\n    class User {\r\n      constructor(options) {\r\n        this.name = options.name;\r\n      }\r\n    }\r\n\r\n    const good = new User({\r\n      name: 'yup',\r\n    });\r\n    ```\r\n\r\n- 클래스의 이름은 **명사** 또는 **명사구문**으로 표기합니다.또한, 인터페이스의 경우 명사 대신 **형용사** 또는 **형용사구문**으로 표기할 수 있습니다..\r\n- 클래스를 export할 때는 **PascalCase**로 표기합니다..","excerpt":"들어가며 개인적으로 코딩 컨밴션을 중요하게 생각하는 편입니다.\n변수명, 함수명 등을 통일된 네이밍으로 사용하는 습관이 필요합니다.\n이 습관은 자신의 코드를 나와 다른 이들이 볼 때 조금 더 빠르고 직관적이게 이해할 수 있는데 도움 될 것입니다.\n그래…","fields":{"slug":"/210315-post/"},"frontmatter":{"date":"Mar 15, 2021","title":"자바스크립트 코딩 컨밴션","tags":["자바스크립트","코딩컨밴션"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\r\n## 📖 Git bash 기본 명령어\r\n\r\n### Git 초기화\r\n\r\n```bash\r\ngit init\r\n```\r\n\r\nGit 초기화를 하면 .git이라는 숨겨진 폴더가 만들어진다. 이것이 로컬 저장소\r\n\r\n로컷 저장소에 내가 만든 버전 정보, 원격 저장소 주소 등이 저장된다.\r\n\r\n원격 저장소에서 내 컴퓨터로 코드를 받아오면 로컬 저장소가 자동으로 생긴다.\r\n\r\n### Git 사용자 정보 등록\r\n\r\n```bash\r\ngit config --global user.name \"Jiwoong Oh\"\r\ngit config --global user.email ojiwoong@gmail.com\r\n```\r\n\r\nGit 커밋 시에 등록할 사용자 정보(이름, 이메일) 등록 \r\n\r\n### Git 원하는 파일 선택\r\n\r\n```bash\r\ngit add index.html\r\n```\r\n\r\n커밋할 파일 선택\r\n\r\n### Git 커밋 메세지를 달아 커밋 생성\r\n\r\n```bash\r\ngit commit -m \"첫번째 커밋\"\r\n```\r\n\r\n커밋메시지 입력\r\n\r\n### 생성한 커밋 히스토리 보기\r\n\r\n```bash\r\ngit log\r\n```\r\n\r\n### 로컬저장소에 GitHub 저장소 연동\r\n\r\n```bash\r\ngit remote add origin https://github.com/ojiwoong/First_Website.git\r\n```\r\n\r\n연동할 저장소 주소 입력\r\n\r\n### 커밋 파일 원격저장소에 저장\r\n\r\n```bash\r\ngit push origin maste\r\n```\r\n\r\n### 원격저장소의 전체파일 로컬저장소에 가져오기\r\n\r\n```bash\r\ngit clone https://github.com/ojiwoong/First_Website.git .\r\n```\r\n\r\n클론할 저장소 주소 입력\r\n\r\n.[점]을 입력해야 현재 폴더에 클론, 미입력 시 새 폴더 생성 및 클론\r\n\r\n### 원격저장소의 변경사항 로컬저장소에 가져오기\r\n\r\n```bash\r\ngit pull origin master\r\n```\r\n\r\n## 📖 유용한 Git 기능들\r\n\r\n### Amend [고치다]\r\n\r\n방금 만든 마지막 커밋에 새로운 내용 추가\r\n\r\n이미 커밋 받은 사람이 있으면 커밋 히스토리가 꼬이기 때문에, 개별적으로 사용하는 브랜치에서만\r\n\r\n주의해서 사용해야함\r\n\r\n### Stash [숨기는 장소]\r\n\r\n작업중이던 파일을 임시로 저장\r\n\r\n### Reset [초기화]\r\n\r\n특정 커밋 히스토리로 되돌림\r\n\r\norigin/master 브랜치도 리셋된 버전으로 변경하기 위해서는 force push [강제푸쉬]를 사용해야 함.\r\n\r\nforce push도 개별적으로 사용하는 브랜치에서만 주의해서 사용해야함.\r\n\r\n[[Reset 명확히 알고가기]](https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-Reset-%EB%AA%85%ED%99%95%ED%9E%88-%EC%95%8C%EA%B3%A0-%EA%B0%80%EA%B8%B0)\r\n\r\n### Revert [되돌림]\r\n\r\n특정 커밋 변경사항을 되돌림\r\n\r\n특정 커밋 히스토리로 되돌아가는 것이 아니라, 새로운 커밋으로 변경사항을 되돌림.\r\n\r\n### Cherry-pick\r\n\r\n다른 별개의 브랜치에서 한 작업의 특정 커밋의 변경사항만 똑 떼서 가져와 커밋\r\n\r\n## 📖 Git 추가 명령어\r\n\r\n```bash\r\ngit init\r\n# 리포지토리 초기화. '.git'폴더 생성. 이 폴더에 현재 폴더와 관련된 관리 정보가 저장. working tree라고 부른다. 변경 내역 등 관리.\r\n\r\ngit status\r\n# 리포지토리 상태 표시. \r\n\r\ngit add 파일명\r\n# 스테이지 영역(커밋 전 임시 영역)에 파일 추가. \r\n\r\ngit commit -m '첫 커밋'\r\n# 스테이지 영역에 기록된 시점들 파일을 실제 리포지토리 변경 내역에 반영.\r\n\r\ngit log\r\n# 리포지토리에 커밋된 로그 확인. \r\n\r\ngit log --pretty=short\r\n# 로그 확인시 첫 번째 요약 줄만 보여주기\r\n\r\ngit log README.md\r\n# 리드미 관련된 로그만 보기 (폴더 명도 가능)\r\n\r\ngit log -p\r\n# 커밋에서 변경된 내용 함께 확인. (뒤에 파일/폴더명 붙여도 됨)\r\n\r\ngit diff\r\n# working tree, 스테이지 영역, 최신 커밋 사이 변경 확인\r\n\r\ngit diff HEAD\r\n# 최신 commit과의 차이 확인\r\n\r\ngit branch\r\n# 브랜치 목록 표시, 현재 어떤 브랜치인지.\r\n\r\ngit checkout -b 'feature-A'\r\n# feature-A 이름의 브랜치 만들고 그 브랜치로 이동\r\n\r\ngit merge --no--ff feature-A\r\n# 현재 브랜치에서 feature-A브랜치를 머지. 옵션은 머지 커밋도 함께 남기고 싶다는 뜻.\r\n\r\ngit log --graph\r\n# 브랜치를 시각적으로 확인\r\n\r\ngit reset --hard 커밋해시값\r\n# HEAD, 스테이지, Working tree를 특정 커밋으로 복원.\r\n\r\ngit reflog\r\n# 현재 브랜치 뿐만이 아니라 이 리포지토리에서 진행된 모든 로그 볼 수 있음\r\n\r\ngit commit --amend\r\n# 바로 전에 작성했던 커밋 메세지 수정\r\n\r\ngit commit -am \"바로 애드하고 커밋하고 싶당\"\r\n# add, commit 한번에 하기\r\n\r\n> git rebase -i HEAD~2\r\npick 7a34294 Add feature-C\r\npick 6fsdfa2 Fix typo\r\n# 현재 브랜치의 HEAD(최신 commit)를 포함한 두 개의 변경 내역과 관련된 내용 보여짐. 이 두개를 합쳐 한 커밋으로 뭉개버리고 싶다. fix typo가 부끄러우니까!\r\n\r\npick 7a34294 Add feature-C\r\nfixup 6fsdfa2 Fix typo\r\n# 뭉개고 싶은 커밋에 'fixup'으로 고쳐주고 저장. \r\n\r\ngit remote add origin git@github.com:사용자명/저장소이름.git\r\n# 주소의 저장소를 원격 저장소로 설정\r\n\r\ngit push -u origin master\r\n# -u옵션: 로컬 리포에 있는 현재 브랜치 upstream이 origin 리포의 master 브랜치로 설정.\r\n\r\ngit push -u origin feature-D\r\n# 원격의 feature-D브랜치로 push\r\n\r\ngit clone git@github....git\r\n# 주소의 리포지토리 받아오기\r\n\r\ngit branch -a\r\n# 로컬 리포지토리랑 원격 리포지토리 브랜치 모두 표시\r\n\r\ngit checkout -b feature-D origin/feature-D\r\n# 원격의 feature-D리포를 내가 새로 만든 feature-D브랜치로 체크아웃\r\n```\r\n\r\n## 📖 커밋 메시지 기본양식\r\n1째 줄 : 변경 내용 한 줄 요약  \r\n2째 줄 : 공백  \r\n3째 줄 부터 : 변경과 관련 내용 상세 기록\r\n","excerpt":"📖 Git bash 기본 명령어 Git 초기화 Git 초기화를 하면 .git이라는 숨겨진 폴더가 만들어진다. 이것이 로컬 저장소 로컷 저장소에 내가 만든 버전 정보, 원격 저장소 주소 등이 저장된다. 원격 저장소에서 내 컴퓨터로 코드를 받아오면 로컬…","fields":{"slug":"/first-post/"},"frontmatter":{"date":"Mar 15, 2021","title":"Git 사용법","tags":["git"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}